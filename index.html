<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cartes disponibles</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: #f4f6f8;
    color: #333;
    margin: 0;
  }
  header {
    background: #fff;
    padding: 20px;
    text-align: center;
    font-size: 1.6em;
    font-weight: bold;
    border-bottom: 1px solid #ddd;
  }
  #counter {
    text-align: center;
    font-size: 1.1em;
    margin: 10px 0;
    font-weight: bold;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    background: #fff;
  }
  thead {
    background: #fafafa;
  }
  thead th {
    padding: 12px 10px;
    font-size: 0.9em;
    text-align: left;
    border-bottom: 1px solid #ddd;
  }
  tbody tr {
    border-bottom: 1px solid #eee;
  }
  tbody tr:hover {
    background: #f9f9f9;
  }
  tbody td {
    padding: 10px;
    font-size: 0.9em;
    vertical-align: middle;
  }
  button.demander {
    background-color: #28a745;
    color: white;
    padding: 6px 14px;
    border: none;
    cursor: pointer;
    font-weight: bold;
    border-radius: 4px;
    font-size: 0.85em;
  }
  button.demander:hover {
    background-color: #218838;
  }
  form {
    margin: 0;
  }
  input.telegramUser {
    padding: 5px;
    font-size: 0.9em;
    width: 140px;
  }
</style>
</head>
<body>

<header>Cartes disponibles</header>
<div id="counter">Chargement des cartes...</div>

<table>
  <thead>
    <tr>
      <th>BIN</th>
      <th>Banque</th>
      <th>Niveau</th>
      <th>Demander</th>
    </tr>
  </thead>
  <tbody id="cardsTable"></tbody>
</table>

<script>
  const mailRecipient = "baranostop28@gmail.com";

  // Pour Ã©viter redemande sur session, stocke les cartes demandÃ©es en localStorage
  let cardsDemanded = JSON.parse(localStorage.getItem('cardsDemanded') || '[]');

  // RÃ©cupÃ©ration et parsing du fichier cards.txt
  fetch('cards.txt')
    .then(res => res.text())
    .then(text => {
      const rawCards = text.split(/ðŸ’³ \+ 1 NEW CARD/).slice(1);
      const cards = rawCards.map(raw => parseCard(raw.trim())).filter(c => c && !cardsDemanded.includes(c.bin));
      displayCards(cards);
      updateCounters(cards);
    })
    .catch(err => {
      console.error("Erreur chargement cards.txt", err);
      document.getElementById('counter').textContent = "Erreur chargement cartes.";
    });

  function parseCard(raw) {
    // RÃ©cupÃ¨re chaque info via regex, case insensitive
    const get = (regex) => {
      const m = raw.match(regex);
      return m ? m[1].trim() : "";
    };

    const bin = get(/Bin\s*:\s*#?(\d{6})/i);
    if (!bin) return null; // bin obligatoire

    const banque = get(/Nom de la banque\s*:\s*(.*)/i) || "Inconnu";
    const niveau = get(/Niveau\s*:\s*(.*)/i).toUpperCase() || "INCONNU";

    return { bin, banque, niveau, raw };
  }

  function updateCounters(cards) {
    const total = cards.length;
    const counts = { CLASSIC:0, GOLD:0, BUSINESS:0, INFINITE:0 };
    cards.forEach(c => {
      if(counts[c.niveau] !== undefined) counts[c.niveau]++;
    });
    document.getElementById('counter').textContent =
      `Total cartes : ${total} | Classic : ${counts.CLASSIC} | Gold : ${counts.GOLD} | Business : ${counts.BUSINESS} | Infinite : ${counts.INFINITE}`;
  }

  function displayCards(cards) {
    const tbody = document.getElementById('cardsTable');
    tbody.innerHTML = "";
    cards.forEach(card => {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${card.bin}</td>
        <td>${card.banque}</td>
        <td>${card.niveau}</td>
        <td>
          <form onsubmit="return demander(event, '${encodeURIComponent(card.raw)}', this)">
            <input type="text" name="telegramUser" class="telegramUser" placeholder="@pseudoTelegram" required />
            <button class="demander" type="submit">Demander</button>
          </form>
        </td>
      `;
      tbody.appendChild(tr);
    });
  }

  function demander(event, rawCardEncoded, form) {
    event.preventDefault();
    const telegramUser = form.telegramUser.value.trim();
    if(!telegramUser || !telegramUser.startsWith('@')){
      alert("Merci de saisir votre pseudo Telegram commenÃ§ant par '@'.");
      return false;
    }
    const rawCard = decodeURIComponent(rawCardEncoded);

    // PrÃ©parer le mail
    const subject = encodeURIComponent("Demande de carte");
    const body = encodeURIComponent(`Carte demandÃ©e:\n\n${rawCard}\n\nPseudo Telegram: ${telegramUser}`);

    // Utiliser mailto pour ouvrir client mail
    window.location.href = `mailto:${mailRecipient}?subject=${subject}&body=${body}`;

    // Supprimer la carte de l'affichage (session)
    removeCardFromDisplay(rawCard);

    return false;
  }

  function removeCardFromDisplay(rawCard) {
    // Retirer la carte de la liste visible en stockant son bin dans localStorage
    const binMatch = rawCard.match(/Bin\s*:\s*#?(\d{6})/i);
    if (!binMatch) return;
    const bin = binMatch[1];
    cardsDemanded.push(bin);
    localStorage.setItem('cardsDemanded', JSON.stringify(cardsDemanded));

    // Supprimer ligne du tableau
    const tbody = document.getElementById('cardsTable');
    const rows = Array.from(tbody.rows);
    for(let row of rows){
      if(row.cells[0].textContent === bin){
        tbody.removeChild(row);
        break;
      }
    }

    // Mettre Ã  jour compteur
    // Recalculer le nombre de cartes restantes
    const remainingCards = rows.length -1;
    // On peut aussi relire les lignes restantes pour compte niveaux
    const cards = [];
    Array.from(tbody.rows).forEach(r => {
      cards.push({
        bin: r.cells[0].textContent,
        banque: r.cells[1].textContent,
        niveau: r.cells[2].textContent
      });
    });
    updateCounters(cards);
  }
</script>

</body>
</html>
